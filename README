Konstantin Agrachev U11597232 Project2

In my threads.c file, I had a few global variables, one that holds the return value for the main thread setjmp, one that acts as a boolean variable for the first call to pthread_create, one that holds the tid for the currently running thread, and my thread table. When pthread_create is called, the statuses of threads in the thread table are set to empty and their ids are set equal to their index in the table. The alarm also gets set up here. The first thread, the main thread, is set to have a status of running. After that, the function tries to find the next available thread (one which has exited or is empty). If a thread isn’t found, the function returns -1, otherwise, it sets the thread up to be executed and returns 0. At some point (50ms into runtime), the scheduler gets called. If there is a thread running (at the start there is, the main thread), it gets its status set back from running to ready and it gets its context saved with setjmp. The return value of setjmp is saved into a variable later to prevent using longjmp twice. Anyways, an available thread is found and executed with longjmp. The cycle of thread scheduling continues until all the threads finish execution. 

One problem I had had to do with me not running the code on bandit. On my own linux environment, whenever I tried creating a thread, I would encounter segfaults right when any variables get initialized inside the routine, even just doing printf statements would cause segfaults. Running the code on bandit fixed any problems I had with this.

I also had a couple problems with my scheduler. I had an if statement specifically for the first call, which turned out to be unnecessary and was causing issues, so I removed it. I was also infinitely looping for threads that were ready, which caused issues when the scheduler tried to find said threads on the very last iteration (this is when all threads are exited or empty, so it shouldn’t find any, looping infinitely means the scheduler never stops running).

